# 内存结构

## 一.程序计数器

![image-20230424110241120](C:\Users\SalmonRun\AppData\Roaming\Typora\typora-user-images\image-20230424110241120.png)

### 1.定义：

Program Counter Register 程序计数器（寄存器）

### 2.作用：

记住下一条jvm指令的执行地址。当需要多线程切换的时候，用来快速恢复到本线程执行的位置。

<img src="C:\Users\SalmonRun\AppData\Roaming\Typora\typora-user-images\image-20230424111247672.png" alt="image-20230424111247672" style="zoom:50%;" />

### 3.特点：

- 是线程私有的
- 不会存在内存溢出



## 二.虚拟机栈

![image-20230424111544764](C:\Users\SalmonRun\AppData\Roaming\Typora\typora-user-images\image-20230424111544764.png)

### 1.定义：

Java Virtual Machine Stacks （Java 虚拟机栈）

每个线程运行时所需要的内存，称为虚拟机栈。

### 2.作用：

每个栈由多个<font color='orange'>栈帧</font>（Frame）组成。

栈帧：每个方法调用时所占用的内存。内存具体有参数，局部变量，返回地址。
每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法。

![image-20230424112222617](C:\Users\SalmonRun\AppData\Roaming\Typora\typora-user-images\image-20230424112222617.png)

### 3.问题

1. 垃圾回收机制是否涉及栈内存？

   不需要。栈帧内存每次调用结束后都会自动释放。

2. 栈内存分配越大越好？

   不是。栈内存划分的越大，线程数越少，增加的只是更多次的方法调用。

3. 方法内的局部变量是否线程安全？

   如果方法内局部变量没有逃离方法的作用访问，它是线程安全的
   如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全

   ①<img src="C:\Users\SalmonRun\AppData\Roaming\Typora\typora-user-images\image-20230425103339096.png" alt="image-20230425103339096" style="zoom:50%;" />

 

上图是安全的，因为这个变量是方法内的局部变量，线程内每一次方法调用都会产生一个新的栈帧，局部变量是线程私有的。

<img src="C:\Users\SalmonRun\AppData\Roaming\Typora\typora-user-images\image-20230425103542883.png" alt="image-20230425103542883" style="zoom:50%;" />

如果是static修饰的变量则不安全。

 ②<img src="C:\Users\SalmonRun\AppData\Roaming\Typora\typora-user-images\image-20230425103934634.png" alt="image-20230425103934634" style="zoom: 67%;" />

上图中1是线程安全的，因为是线程内的局部变量，是每个线程私有的。

2是非线程安全的。因为可以传参，有可能会有其他线程访问到。

3是非线程安全的。因为有返回值，也有可能被其他线程访问到。

### 4.栈内存溢出

`java.lang.StackOverflowError`

1. 栈帧过多导致栈内存溢出。

   一直调用只有入栈，没有出栈。

   2.栈帧过大直接超过栈内存。

## 三.本体方法栈

![image-20230425113719139](C:\Users\SalmonRun\AppData\Roaming\Typora\typora-user-images\image-20230425113719139.png)

本地方法：不是由Java代码写的方法。

## 四.堆

![image-20230425113812104](C:\Users\SalmonRun\AppData\Roaming\Typora\typora-user-images\image-20230425113812104.png)

### 1.特点：

- 通过 new 关键字，创建对象都会使用堆内存
- 它是线程共享的，堆中对象都需要考虑线程安全的问题
- 有垃圾回收机制

### 2.内存溢出

## 五.方法区

![image-20230425204908552](C:\Users\SalmonRun\AppData\Roaming\Typora\typora-user-images\image-20230425204908552.png)

### 1.基本理解：

- 在一个jvm实例的内部，类型信息被存储在一个称为方法区的内存逻辑区中。类型信息是由类加载器在类加载时从类文件中提取出来的。类(静态)变量也存储在方法区中。
- 概念上定义了方法区是堆的一部分，但是具体的不同厂商在实现jvm的时候，不一定会遵循逻辑上的定义。
- HotSpot中永久代和元空间都是实现方法区。1.6中是永久代，在堆中。1.8是元空间，在本地内存中。
- 方法区（(Method Area）与Java堆一样，是各个线程共享的内存区域。
- <img src="C:\Users\SalmonRun\AppData\Roaming\Typora\typora-user-images\image-20230426104237165.png" alt="image-20230426104237165" style="zoom:60%;" />
- 方法区在JVM**启动**的时候被创建,并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。
- 方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。
- 方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误: java.lang.outOfMemoryError
- PermGen space或者java.lang. outOfMemoryError: Metaspace
  - 加载大量的第三方的Jar包
  - Tomcat部署的工程太多
  - 大量动态的生成反射类
- 关闭JVM就会释放这个区域的内存。

### 2.内存溢出：

`java.lang.OutOfMemoryError:MetaSpace`

`java.lang.OutOfMemoryError:PermGen space`

