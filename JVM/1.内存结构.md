# 内存结构

**线程私有的：**

- 程序计数器
- 虚拟机栈
- 本地方法栈

**线程共享的：**

- 堆
- 方法区
- 直接内存 (非运行时数据区的一部分)

Java 虚拟机规范对于运行时数据区域的规定是相当宽松的。以堆为例：堆可以是连续空间，也可以不连续。堆的大小可以固定，也可以在运行时按需扩展 。虚拟机实现者可以使用任何垃圾回收算法管理堆，甚至完全不进行垃圾收集也是可以的。

## 程序计数器

**作用：**

记住下一条jvm指令的执行地址，实现代码的流程控制分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成

当需要多线程切换的时候，用来快速恢复到本线程执行的位置。

**特点：**

- 是线程私有的
- 不会存在内存溢出

程序计数器是唯一一个不会出现 `OutOfMemoryError` 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。



## 虚拟机栈

**定义：**

每个线程运行时所需要的内存，称为虚拟机栈。

**作用：**

每个栈由多个栈帧（Frame）组成。

方法调用的数据需要通过栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。

栈帧：每个方法调用时所占用的内存。内存具体有参数，局部变量，返回地址。
每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法。

**局部变量表** 主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。

**操作数栈** 主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。

**动态链接** 主要服务一个方法需要调用其他方法的场景。

**问题**

1. 垃圾回收机制是否涉及栈内存？

   不需要。栈帧内存每次调用结束后都会自动释放。

2. 栈内存分配越大越好？

   不是。栈内存划分的越大，线程数越少，增加的只是更多次的方法调用。

3. 方法内的局部变量是否线程安全？

   如果方法内局部变量没有逃离方法的作用访问，它是线程安全的
   如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全

 栈可能会出现两种错误：

**`StackOverFlowError`：** 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 `StackOverFlowError` 错误。（递归可能会出现的异常）

**`OutOfMemoryError`：** 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出`OutOfMemoryError`异常

## 本体方法栈

和虚拟机栈所发挥的作用非常相似，区别是：**虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。

方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 `StackOverFlowError` 和 `OutOfMemoryError` 两种错误。

## 堆

Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**

Java 堆是垃圾收集器管理的主要区域，因此也被称作 **GC 堆（Garbage Collected Heap）**。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。进一步划分的目的是更好地回收内存，或者更快地分配内存。 

**特点：**

- 通过 new 关键字，创建对象都会使用堆内存
- 它是线程共享的，堆中对象都需要考虑线程安全的问题
- 有垃圾回收机制

**内存溢出**

## 方法区

**1.基本理解：**

- 在一个jvm实例的内部，类型信息被存储在一个称为方法区的内存逻辑区中。类型信息是由类加载器在类加载时从类文件中提取出来的。类(静态)变量也存储在方法区中。
- 概念上定义了方法区是堆的一部分，但是具体的不同厂商在实现jvm的时候，不一定会遵循逻辑上的定义。
- HotSpot中永久代和元空间都是实现方法区。1.6中是永久代，在堆中。1.8是元空间，在本地内存中。
- 方法区（(Method Area）与Java堆一样，是各个线程共享的内存区域。
- <img src="C:\Users\SalmonRun\AppData\Roaming\Typora\typora-user-images\image-20230426104237165.png" alt="image-20230426104237165" style="zoom:60%;" />
- 方法区在JVM**启动**的时候被创建,并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。
- 方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。
- 方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误: java.lang.outOfMemoryError
- PermGen space或者java.lang. outOfMemoryError: Metaspace
  - 加载大量的第三方的Jar包
  - Tomcat部署的工程太多
  - 大量动态的生成反射类
- 关闭JVM就会释放这个区域的内存。

**2.内存溢出：**

`java.lang.OutOfMemoryError:MetaSpace`

`java.lang.OutOfMemoryError:PermGen space`

