# 凉经

## 招银科技二面：

### 1.spring boot实现一个增加接口的时候需要考虑什么问题？

1. **数据验证与合法性检查**：
   - 在接口接收到数据之前，应该进行数据验证和合法性检查，确保传入的数据满足预期的格式和条件。
   - 使用Spring的Validation框架或自定义验证逻辑，处理输入数据的验证。
2. **安全性**：
   - 考虑接口的安全性，确保只有授权的用户或应用程序可以访问增加接口。
   - 使用身份验证和授权机制，如OAuth 2.0或基本认证，来保护接口。
3. **异常处理**：
   - 处理可能出现的异常情况，如数据验证失败、数据库错误等。
   - 使用Spring的异常处理机制，将异常信息转化为合适的HTTP响应。
4. **事务管理**：
   - 如果增加操作涉及到多个数据库操作，确保使用事务来保持数据一致性。
   - 使用Spring的声明式事务管理，以便在方法级别管理事务。
5. **请求与响应**：
   - 定义清晰的请求和响应模型，以明确接口的输入和输出。
   - 使用HTTP状态码来指示操作结果，如201 Created表示创建成功。
6. **数据存储**：
   - 考虑如何将数据存储到数据库或其他持久性存储中。
   - 使用Spring Data JPA、Hibernate或其他持久性框架来处理数据持久化。
7. **输入数据的处理**：
   - 处理输入数据，确保数据安全性，如防止SQL注入攻击。
   - 使用参数化查询或ORM框架来安全地构建数据库查询。
8. **日志记录**：
   - 添加适当的日志记录，以便跟踪接口的操作和问题排查。
   - 使用Spring Boot的日志记录机制，如Logback或Log4j。
9. **性能优化**：
   - 考虑性能问题，确保接口能够承受高负载。
   - 使用缓存、数据库索引等技术来优化查询和数据操作。
10. **错误处理和反馈**：
    - 提供清晰的错误消息，以便客户端能够理解问题并采取适当的措施。
    - 定义一致的错误格式，如JSON格式的错误响应。
11. **单元测试与集成测试**：
    - 编写单元测试和集成测试，确保增加接口的正确性和稳定性。
    - 使用Spring Boot的测试框架，如JUnit和Spring Test。
12. **文档和Swagger**：
    - 创建接口文档，以便其他开发人员可以轻松了解如何使用接口。
    - 使用Swagger或类似的工具自动生成API文档。

### 2.当一个接口数据量访问量很大的时候需要考虑什么问题？

1. **性能优化**：
   - 考虑并发请求和大规模数据处理，优化数据库查询、算法和数据结构，以减少响应时间。
2. **分页和筛选**：
   - 实施数据分页，以限制每个请求返回的数据量。客户端可以使用分页参数来获取更多数据。
   - 提供筛选和排序选项，以便客户端可以精确地获取所需的数据。
3. **索引和数据库优化**：
   - 确保数据库表有适当的索引，以加速查询操作。
   - 定期执行数据库性能分析和优化，以确保数据库操作的效率。
4. **请求限制和配额**：
   - 实施请求限制和配额，以防止恶意或不合理的大量请求。使用API密钥、令牌或IP地址来限制访问。
5. **异步处理**：
   - 对于需要时间较长的操作，考虑使用异步处理，将请求放入队列中，然后在后台处理，以释放请求线程并提高并发性。
6. **负载均衡**：
   - 使用负载均衡器来分发流量到多个服务器实例，以确保高可用性和分布式处理。
   - 考虑使用容器编排工具，如Docker Swarm或Kubernetes，以管理容器实例的扩展和负载均衡。
7. **监控和日志**：
   - 设置监控和警报系统，以实时监测系统性能和问题。
   - 记录详细的日志，以便跟踪问题并进行故障排除。
8. **缓存**：
   - 使用缓存来存储计算结果、静态数据或频繁访问的数据，以减轻数据库压力。
   - 考虑使用分布式缓存系统，如Redis，以支持多台服务器上的数据共享。
9. **数据压缩和分片**：
   - 如果数据量非常大，可以考虑使用数据压缩技术来减小数据传输的大小。
   - 分片数据，将数据存储在多个服务器上，以便扩展数据存储能力。
10. **容错和回退策略**：
    - 实施容错机制，处理可能的故障或异常情况，确保系统的可靠性。
    - 提供回退策略，以防止请求失败时提供默认数据或备用服务。
11. **安全性**：
    - 对于大规模数据，确保严格的安全性措施，包括数据加密、身份验证和授权。
    - 定期进行安全性审计，以识别潜在的漏洞。

### 3.当一个接口很慢的时候，怎么去排查问题？

1. **性能监控**：
   - 使用性能监控工具来实时监测接口的性能指标，如响应时间、CPU使用率、内存使用率和请求速率。常见的监控工具包括Prometheus、Grafana、New Relic等。
2. **日志分析**：
   - 检查应用程序的日志以查看是否存在异常或错误信息。
   - 记录关键的性能指标，如请求处理时间、数据库查询时间等，以便后续分析。
3. **数据库查询分析**：
   - 如果接口涉及数据库操作，检查数据库查询执行计划，以确定是否存在慢查询。
   - 确保数据库表有适当的索引以加速查询操作。
4. **资源利用率**：
   - 检查服务器的资源利用率，包括CPU、内存和磁盘使用情况。高资源利用率可能会导致接口变慢。
   - 查看系统负载情况，确保服务器不会过载。
5. **网络延迟**：
   - 测量网络延迟，确保网络连接稳定。网络问题可能导致接口响应变慢。
   - 使用网络诊断工具，如ping或traceroute，来检查网络连接问题。
6. **并发问题**：
   - 考虑并发问题，检查是否存在竞态条件或锁竞争，导致接口响应时间增加。
   - 使用线程和进程分析工具来识别并发问题。
7. **第三方依赖**：
   - 如果接口依赖于其他服务或第三方服务，检查这些服务是否出现问题或变慢。
   - 考虑异步调用或使用断路器模式来处理依赖故障。
8. **代码分析**：
   - 通过代码审查和分析，检查是否存在低效或复杂的代码路径。
   - 使用性能分析工具，如VisualVM或YourKit，来识别性能瓶颈。
9. **缓存分析**：
   - 如果接口使用缓存，检查缓存是否工作正常。缓存未命中可能导致较慢的响应时间。
   - 查看缓存的命中率和失效率。
10. **负载测试**：
    - 执行负载测试来模拟高并发情况，以找出在高负载下性能下降的原因。
    - 分析负载测试的结果，确定性能瓶颈。
11. **代码剖析**：
    - 使用性能剖析工具，如Java的VisualVM或Python的cProfile，来识别代码中的性能瓶颈。
    - 根据剖析结果进行代码优化。
12. **缓存优化**：
    - 如果接口使用缓存，考虑优化缓存策略，如缓存预热、定期刷新等。
13. **数据库连接池**：
    - 如果使用数据库，检查数据库连接池的配置，确保它能够满足高并发需求。

## 美团一面：

### 1.HashMap线程不安全的时候会发生什么？

**并发修改导致数据不一致**

HashMap的数据结构是基于数组和链表实现的。在进行插入或删除操作时，如果不同线程同时修改同一个位置的元素，就会导致数据不一致的情况。具体来说，当两个线程同时进行插入操作时，假设它们都要插入到同一个数组位置，并且该位置没有元素，那么它们都会认为该位置可以插入元素，最终就会导致其中一个线程的元素被覆盖掉。此外，在进行删除操作时，如果两个线程同时删除同一个元素，也会导致数据不一致的情况。

**并发扩容导致死循环或数据丢失**

当两个线程同时进行扩容操作时，它们可能会同时将某个元素映射到新的数组上，从而导致该元素被覆盖掉。

1.7头插法会导致死循环：在进行扩容操作时，如果线程不安全地修改了next指针，就可能会导致死循环的情况。1.8以后尾插法解决了问题。

**线程之间的可见性不安全问题**

由于 HashMap 不是线程安全的，因此多个线程可能会同时访问同一个 HashMap 实例。

而当一个线程对 HashMap 进行修改时，其他线程可能无法立即看到这些修改，这就可能导致数据不一致的问题。

### 2.设计模式

https://www.cnblogs.com/chenssy/p/3357683.html

1. **单例模式 (Singleton Pattern)**：确保一个类只有一个实例，并提供一个全局访问点。
2. **工厂模式 (Factory Pattern)**：创建对象的过程封装在一个工厂类中，以便根据需求创建不同类型的对象。**工厂模式**通常用于创建单一类型的对象，它只有一个工厂类负责创建这一种对象。
3. **抽象工厂模式 (Abstract Factory Pattern)**：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定它们的具体类。用于创建一组相关的对象，这组对象通常有某种关联或依赖关系，每个工厂类负责创建其中一组对象。
4. **适配器模式 (Adapter Pattern)**：允许接口不兼容的类协同工作，将一个类的接口转换成客户端期望的接口。
5. **装饰器模式 (Decorator Pattern)**：动态地将责任附加到对象上，以扩展其功能。它是继承的替代方法。

### 3.Mybatis sql注入分析

**什么是sql注入？**

当我们使用字符串拼接的时候在，攻击者输入框中输入一些特殊字符，造成SQL语句执行异常。

**怎么防止sql注入？**

**使用参数化查询：**

- **定义方式**：在 MyBatis 中，你使用 `#{param}` 格式的占位符来表示参数。这些占位符将被 MyBatis 替换为实际参数值，并确保在替换过程中正确地进行转义和安全处理。

- **示例**：以下是使用参数化查询的示例，其中 `#{userId}` 是占位符，它将被实际的用户ID值替换。

  ```sql
  xmlCopy code<select id="getUserById" parameterType="int" resultType="User">
      SELECT * FROM users WHERE id = #{userId}
  </select>
  ```

**使用动态 SQL：** 

MyBatis 提供了动态 SQL 的功能，允许你根据不同的条件构建不同的 SQL 查询。当你需要根据用户输入动态构建查询时，确保正确地使用动态 SQL 并进行参数化处理。

例如，使用 `<if>` 元素来构建动态的 WHERE 子句：

```sql
xmlCopy code<select id="getUserByConditions" resultType="User">
    SELECT * FROM users
    <where>
        <if test="username != null">
            AND username = #{username}
        </if>
        <if test="email != null">
            AND email = #{email}
        </if>
    </where>
</select>
```



**SQL参数化查询为什么能够防止SQL注入？**

**1、参数化查询是什么**

参数化查询是指查询数据库时，在需要填入数据的地方，使用参数来给值。

**2、SQL 语句的执行处理**

SQL 语句按处理流程看有两类：即时 SQL、预处理 SQL。

- 即时 SQL

即时 SQL 从 DB 接收到最终执行完毕返回，大致的过程如下：

特点：一次编译，单次运行。

- 预处理 SQL

程序中某条 sql 可能会被反复调用，或者每次执行的时候只有个别的值不同。如果每次按即时 SQL 的流程来看，效率是比较低的。

这时候可以将 SQL 中的值用占位符代替，先生成 SQL 模板，然后再绑定参数，之后重复执行该语句的时候只需要替换参数，而不用再去进行词法和语义分析。可以视为 SQL 语句模板化或参数化。

**预处理 SQL 是如何防止 SQL 注入的**

待执行的 SQL 被编译后存放在缓存池中，DB 执行 execute 的时候，并不会再去编译一次，而是找到 SQL 模板，将参数传递给它然后执行。所以类似于 or 1==1 的命令会当成参数传递，而不会进行语义解析执行。

**#和$区别**

\#{} 解析为一个 JDBC 预编译语句（prepared statement）的参数标记符，一个 #{ } 被解析为一个参数占位符；而${}仅仅为一个纯碎的 string 替换，在动态 SQL 解析阶段将会进行变量替换。

\#{} 解析之后会将String类型的数据自动加上引号，其他数据类型不会；而${} 解析之后是什么就是什么，他不会当做字符串处理。

\#{} 很大程度上可以防止SQL注入（SQL注入是发生在编译的过程中，因为恶意注入了某些特殊字符，最后被编译成了恶意的执行操作）；而{} 主要用于SQL拼接的时候，有很大的SQL注入隐患。 

在某些特殊场合下只能用${}，不能用#{}。

例如：在使用排序时ORDER BY ${id}，如果使用#{id}，则会被解析成ORDER BY “id”,这显然是一种错误的写法。·

## 得物一面：

### 1.线程间通信的方式

### 2.Redis持久化方式

Redis支持两种主要的持久化机制：快照（Snapshot）和日志追加（Append-Only File）。

1. 快照（Snapshot）持久化：
   - 快照持久化是将Redis数据库的状态定期保存到磁盘文件中。这个过程通过将内存中的数据以快照的形式写入一个二进制文件（dump.rdb）来完成。
   - 管理快照的频率可以通过配置文件中的参数来控制。可以设置在多少秒内，或者在多少个修改操作后生成一个快照。
   - 快照持久化的优点是它非常高效，因为它只需要在指定的时间间隔内创建快照文件，不需要在每次写操作时都进行磁盘写入。
   - 缺点是如果Redis在两次快照之间崩溃，可能会丢失最后一次快照之后的数据。
2. 日志追加（Append-Only File）持久化：
   - 日志追加持久化是将每个写操作追加到一个日志文件（appendonly.aof）中，而不是定期保存整个数据库快照。
   - 这种持久化方式更安全，因为每个写操作都被记录下来，可以确保数据的完整性。
   - 日志追加持久化的缺点是相对于快照持久化来说，它可能会占用更多的磁盘空间，因为每个写操作都会被记录下来。
   - 此外，日志追加持久化在某些情况下可能会降低写入性能，因为每个写操作都需要追加到文件中。

## 云智一面：

代码题，找参加的人数，求出频次最高的。不用map怎么统计频次？怎么原地统计？

怎么让你写的Map查找时间复杂度最高？

### newHashMap时候的参数有哪些？

哪些变量存在堆中，哪些存在栈中？

### 怎么让写的代码堆溢出？

### 怎么让写的代码栈溢出？

了解迭代器吗？

Hash解决冲突的方式？

concurrentHashMap底层？

### 红黑树和普通的平衡二叉树的区别？

索引失效

手写SQL

索引数据结构

## 经纬恒润一面：

### token、session、cookie

#### **cookie：**

存在客户端。http是无状态的，需要有一个机制记录连接的关系，使用cookie。

**工作机制：**以加入购物车为例，每次浏览器请求后 server 都会将本次商品 id 存储在 Cookie 中返回给客户端，客户端会将 Cookie 保存在本地，下一次再将上次保存在本地的 Cookie 传给 server 就行了，这样每个 Cookie 都保存着用户的商品 id，购买记录也就不会丢失了。

缺点是cookie会越来越大。

#### session：

存在服务端。仔细考虑下，由于用户的购物车信息都会保存在 Server 中，所以在 Cookie 里只要保存能识别用户身份的信息，知道是谁发起了加入购物车操作即可，这样每次请求后只要在 Cookie 里带上用户的身份信息，请求体里也只要带上本次加入购物车的商品 id，大大减少了 cookie 的体积大小，我们把这种能识别哪个请求由哪个用户发起的机制称为 Session（会话机制），生成的能识别用户身份信息的字符串称为 sessionId。

**工作机制：**

1. 首先用户登录，server 会为用户生成一个 session，为其分配唯一的 sessionId，这个 sessionId 是与某个用户绑定的，也就是说根据此 sessionid（假设为 abc） 可以查询到它到底是哪个用户，然后将此 sessionid 通过 cookie 传给浏览器。
2. 之后浏览器的每次添加购物车请求中只要在 cookie 里带上 sessionId=abc 这一个键值对即可，server 根据 sessionId 找到它对应的用户后，把传过来的商品 id 保存到 server 中对应用户的购物车即可。

sessionId 需要借助 cookie 的传递才有意义。

**session的痛点：**

假设登录请求打到了 A 机器，A 机器生成了 session 并在 cookie 里添加 sessionId 返回给了浏览器，那么问题来了：下次添加购物车时如果请求打到了 B 或者 C，由于 session 是在 A 机器生成的，此时的 B,C 是找不到 session 的，那么就会发生无法添加购物车的错误，就得重新登录了，此时请问该怎么办。

主要有以下三种方式：复制、粘连、共享。

#### token：

存在客户端。首先请求方输入自己的用户名，密码，然后 server 据此生成 token，客户端拿到 token 后会保存到本地，之后向 server 请求时在请求头带上此 token 即可。

1、 token 只存储在浏览器中，服务端却没有存储，这样的话我随便搞个 token 传给 server 也行？

```
答：server 会有一套校验机制，校验这个 token 是否合法。
```

2、怎么不像 session 那样根据 sessionId 找到 userid 呢，这样的话怎么知道是哪个用户？

```
答：token 本身携带 uid 信息
```

#### 总结：

session 和 token 本质上是没有区别的，都是对用户身份的认证机制，只是他们实现的校验机制不一样而已（一个保存在 server，通过在 redis 等中间件获取来校验，一个保存在 client，通过签名校验的方式来校验），多数场景上使用 session 会更合理，但如果在单点登录，一次性命令认证上使用 token 会更合适，最好在不同的业务场景中合理选型，才能达到事半功倍的效果。

### 过滤器和拦截器的区别：

**1、拦截器不依赖于servlet容器是SpringMVC自带的，过滤器依赖于Servlet容器。**

**2、拦截器是基于java的反射机制的，而过滤器是基于函数回调。**

**3、拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。**

**4、拦截器可以访问controller上下文、值栈里的对象，而过滤器不能访问。**

拦截器的preHandle方法在进入controller前执行，而拦截器的postHandle方法在执行完controller业务流程后，在视图解析器解析ModelAndView之前执行，可以操控Controller的ModelAndView内容。而afterCompletion是在视图解析器解析渲染ModelAndView完成之后执行的

过滤器是在服务器启动时就会创建的，只会创建一个实例，常驻内存，也就是说服务器一启动就会执行Filter的init(FilterConfig config)方法.当Filter被移除或服务器正常关闭时，会执行destroy方法

**5、拦截器可以获取IOC容器中的各个bean，而过滤器就不行，在拦截器里注入一个service，可以调用业务逻辑。**

关于这句话的解读是：我们知道拦截器是SprinMVC自带的，而SpringMVC存在Controller层的，而controller层可以访问到service层，service层是不能访问service层的，而过滤器是客户端和服务端之间请求与响应的过滤

**6、过滤器和拦截器触发时机、时间、地方不一样**

过滤器是在请求进入容器后，但请求进入servlet之前进行预处理的。请求结束返回也是在servlet处理完后

**7、过滤器包裹住servlet，servlet包裹住拦截器**

### 创建对象的方式有哪些？

| 方式                                       | 是否用了构造函数 |
| ------------------------------------------ | ---------------- |
| 使用New关键字                              | 是               |
| 使用Class类的newInstance方法（反射）       | 是               |
| 使用Constructor类的newInstance方法（反射） | 是               |
| clone方法                                  | 否               |
| 反序列化                                   | 否               |

1. 使用new关键字

这是最常见也是最简单的创建对象的方式了。通过这种方式，我们可以调用任意的构造函数(无参的和带参数的)。

```java
Student s = new Student();
```

2. 使用Class类的newInstance方法（反射）

我们也可以使用Class类的newInstance方法创建对象。这个newInstance方法调用**无参**的构造函数创建对象。

```java
Employee emp2 = (Employee) Class.forName("org.programming.mitra.exercises.Employee").newInstance();
//或者
Employee emp2 = Employee.class.newInstance();
```

3. 使用Constructor类的newInstance方法

和Class类的newInstance方法很像， java.lang.reflect.Constructor类里也有一个newInstance方法可以创建对象。我们可以通过这个newInstance方法调用**有参数的和私有的构造函数**。

```java
Constructor<Employee> constructor = Employee.class.getConstructor();
Employee emp3 = constructor.newInstance();
```

这两种newInstance方法就是大家所说的**反射**。事实上Class的newInstance方法内部调用Constructor的newInstance方法。

4. 使用clone方法

无论何时我们调用一个对象的clone方法，jvm就会创建一个新的对象，将前面对象的内容全部拷贝进去。用clone方法创建对象并不会调用任何构造函数。

要使用clone方法，我们需要先实现Cloneable接口并实现其定义的clone方法。

```java
Employee emp4 = (Employee) emp3.clone();
```

5. 使用反序列化

当我们序列化和反序列化一个对象，jvm会给我们创建一个单独的对象。在反序列化时，jvm创建对象并不会调用任何构造函数。
为了反序列化一个对象，我们需要让我们的类实现Serializable接口。

```java
ObjectInputStream in = new ObjectInputStream(new FileInputStream("data.obj"));
Employee emp5 = (Employee) in.readObject();
```

从上面的例子可以看出来，除了使用new关键字之外的其他方法全部都是转变为invokevirtual（创建对象的直接方法），使用被new的方式转变为两个调用，new和invokespecial（构造函数调用）。

### 创建线程的方式有哪些？

1. 实现Runnable接口

2. 继承Thread类

3. 实现Callable接口

4. 使用线程池

5. 使用匿名类

   Runnable和Callable的区别：

   runnable没有返回值，而实现callable接口的任务线程能返回执行结果。
   callable接口实现类中的run方法允许异常向上抛出，可以在内部处理，try catch，但是runnable接口实现类中run方法的异常必须在内部处理，不能抛出。



## CVTE一面：

synchronized具体做了哪些改进？

线程安全的性能好的list？

页分裂？

当一个接口，因为并发量很大导致慢，怎么排查？



