# 凉经

## 招银科技二面：

### 1.redis除了作缓存还有什么用处？

消息队列：Redis可以作为一种高性能的消息队列使用，实现异步处理和解耦。Redis支持列表数据类型，可以将消息存储在列表中，并且支持阻塞式操作，可以实现消息队列的等待和通知机制。

分布式锁：Redis可以作为一种分布式锁的存储层，通过缓存锁信息和锁状态，实现分布式锁和并发控制。Redis支持多种数据类型，包括字符串、哈希、列表、集合和有序集合，可以根据不同的场景选择合适的数据类型来实现分布式锁。

计数器：Redis可以作为一种计数器的存储层，通过原子操作实现计数器的自增和自减，支持高并发的计数操作。Redis还支持多种数据类型，包括哈希、列表、集合和有序集合，可以实现多维度的计数功能。

数据库：Redis可以作为一种轻量级的数据库使用，支持持久化和数据备份，可以用于存储少量的数据和应用场景。Redis支持多种数据类型，可以根据不同的数据特性和访问模式选择合适的数据类型来存储数据。

### 2.当你用spring boot实现一个增加接口的时候需要考虑什么问题？

1. **数据验证与合法性检查**：
   - 在接口接收到数据之前，应该进行数据验证和合法性检查，确保传入的数据满足预期的格式和条件。
   - 使用Spring的Validation框架或自定义验证逻辑，处理输入数据的验证。
2. **安全性**：
   - 考虑接口的安全性，确保只有授权的用户或应用程序可以访问增加接口。
   - 使用身份验证和授权机制，如OAuth 2.0或基本认证，来保护接口。
3. **异常处理**：
   - 处理可能出现的异常情况，如数据验证失败、数据库错误等。
   - 使用Spring的异常处理机制，将异常信息转化为合适的HTTP响应。
4. **事务管理**：
   - 如果增加操作涉及到多个数据库操作，确保使用事务来保持数据一致性。
   - 使用Spring的声明式事务管理，以便在方法级别管理事务。
5. **请求与响应**：
   - 定义清晰的请求和响应模型，以明确接口的输入和输出。
   - 使用HTTP状态码来指示操作结果，如201 Created表示创建成功。
6. **数据存储**：
   - 考虑如何将数据存储到数据库或其他持久性存储中。
   - 使用Spring Data JPA、Hibernate或其他持久性框架来处理数据持久化。
7. **输入数据的处理**：
   - 处理输入数据，确保数据安全性，如防止SQL注入攻击。
   - 使用参数化查询或ORM框架来安全地构建数据库查询。
8. **日志记录**：
   - 添加适当的日志记录，以便跟踪接口的操作和问题排查。
   - 使用Spring Boot的日志记录机制，如Logback或Log4j。
9. **性能优化**：
   - 考虑性能问题，确保接口能够承受高负载。
   - 使用缓存、数据库索引等技术来优化查询和数据操作。
10. **错误处理和反馈**：
    - 提供清晰的错误消息，以便客户端能够理解问题并采取适当的措施。
    - 定义一致的错误格式，如JSON格式的错误响应。
11. **单元测试与集成测试**：
    - 编写单元测试和集成测试，确保增加接口的正确性和稳定性。
    - 使用Spring Boot的测试框架，如JUnit和Spring Test。
12. **文档和Swagger**：
    - 创建接口文档，以便其他开发人员可以轻松了解如何使用接口。
    - 使用Swagger或类似的工具自动生成API文档。

### 3.当一个接口可能被很大的数据量访问的时候，需要考虑什么问题？

1. **性能优化**：
   - 考虑并发请求和大规模数据处理，优化数据库查询、算法和数据结构，以减少响应时间。
2. **分页和筛选**：
   - 实施数据分页，以限制每个请求返回的数据量。客户端可以使用分页参数来获取更多数据。
   - 提供筛选和排序选项，以便客户端可以精确地获取所需的数据。
3. **索引和数据库优化**：
   - 确保数据库表有适当的索引，以加速查询操作。
   - 定期执行数据库性能分析和优化，以确保数据库操作的效率。
4. **请求限制和配额**：
   - 实施请求限制和配额，以防止恶意或不合理的大量请求。使用API密钥、令牌或IP地址来限制访问。
5. **异步处理**：
   - 对于需要时间较长的操作，考虑使用异步处理，将请求放入队列中，然后在后台处理，以释放请求线程并提高并发性。
6. **负载均衡**：
   - 使用负载均衡器来分发流量到多个服务器实例，以确保高可用性和分布式处理。
   - 考虑使用容器编排工具，如Docker Swarm或Kubernetes，以管理容器实例的扩展和负载均衡。
7. **监控和日志**：
   - 设置监控和警报系统，以实时监测系统性能和问题。
   - 记录详细的日志，以便跟踪问题并进行故障排除。
8. **缓存**：
   - 使用缓存来存储计算结果、静态数据或频繁访问的数据，以减轻数据库压力。
   - 考虑使用分布式缓存系统，如Redis，以支持多台服务器上的数据共享。
9. **数据压缩和分片**：
   - 如果数据量非常大，可以考虑使用数据压缩技术来减小数据传输的大小。
   - 分片数据，将数据存储在多个服务器上，以便扩展数据存储能力。
10. **容错和回退策略**：
    - 实施容错机制，处理可能的故障或异常情况，确保系统的可靠性。
    - 提供回退策略，以防止请求失败时提供默认数据或备用服务。
11. **安全性**：
    - 对于大规模数据，确保严格的安全性措施，包括数据加密、身份验证和授权。
    - 定期进行安全性审计，以识别潜在的漏洞。

### 4.当一个接口很慢的时候，怎么去排查问题？

1. **性能监控**：
   - 使用性能监控工具来实时监测接口的性能指标，如响应时间、CPU使用率、内存使用率和请求速率。常见的监控工具包括Prometheus、Grafana、New Relic等。
2. **日志分析**：
   - 检查应用程序的日志以查看是否存在异常或错误信息。
   - 记录关键的性能指标，如请求处理时间、数据库查询时间等，以便后续分析。
3. **数据库查询分析**：
   - 如果接口涉及数据库操作，检查数据库查询执行计划，以确定是否存在慢查询。
   - 确保数据库表有适当的索引以加速查询操作。
4. **资源利用率**：
   - 检查服务器的资源利用率，包括CPU、内存和磁盘使用情况。高资源利用率可能会导致接口变慢。
   - 查看系统负载情况，确保服务器不会过载。
5. **网络延迟**：
   - 测量网络延迟，确保网络连接稳定。网络问题可能导致接口响应变慢。
   - 使用网络诊断工具，如ping或traceroute，来检查网络连接问题。
6. **并发问题**：
   - 考虑并发问题，检查是否存在竞态条件或锁竞争，导致接口响应时间增加。
   - 使用线程和进程分析工具来识别并发问题。
7. **第三方依赖**：
   - 如果接口依赖于其他服务或第三方服务，检查这些服务是否出现问题或变慢。
   - 考虑异步调用或使用断路器模式来处理依赖故障。
8. **代码分析**：
   - 通过代码审查和分析，检查是否存在低效或复杂的代码路径。
   - 使用性能分析工具，如VisualVM或YourKit，来识别性能瓶颈。
9. **缓存分析**：
   - 如果接口使用缓存，检查缓存是否工作正常。缓存未命中可能导致较慢的响应时间。
   - 查看缓存的命中率和失效率。
10. **负载测试**：
    - 执行负载测试来模拟高并发情况，以找出在高负载下性能下降的原因。
    - 分析负载测试的结果，确定性能瓶颈。
11. **代码剖析**：
    - 使用性能剖析工具，如Java的VisualVM或Python的cProfile，来识别代码中的性能瓶颈。
    - 根据剖析结果进行代码优化。
12. **缓存优化**：
    - 如果接口使用缓存，考虑优化缓存策略，如缓存预热、定期刷新等。
13. **数据库连接池**：
    - 如果使用数据库，检查数据库连接池的配置，确保它能够满足高并发需求。

## 美团一面：

### 1.HashMap线程不安全的时候会发生什么？

**并发修改导致数据不一致**

HashMap的数据结构是基于数组和链表实现的。在进行插入或删除操作时，如果不同线程同时修改同一个位置的元素，就会导致数据不一致的情况。具体来说，当两个线程同时进行插入操作时，假设它们都要插入到同一个数组位置，并且该位置没有元素，那么它们都会认为该位置可以插入元素，最终就会导致其中一个线程的元素被覆盖掉。此外，在进行删除操作时，如果两个线程同时删除同一个元素，也会导致数据不一致的情况。

**并发扩容导致死循环或数据丢失**

当两个线程同时进行扩容操作时，它们可能会同时将某个元素映射到新的数组上，从而导致该元素被覆盖掉。

1.7头插法会导致死循环：在进行扩容操作时，如果线程不安全地修改了next指针，就可能会导致死循环的情况。1.8以后尾插法解决了问题。

**线程之间的可见性不安全问题**

由于 HashMap 不是线程安全的，因此多个线程可能会同时访问同一个 HashMap 实例。

而当一个线程对 HashMap 进行修改时，其他线程可能无法立即看到这些修改，这就可能导致数据不一致的问题。

### 2.设计模式

https://www.cnblogs.com/chenssy/p/3357683.html

1. **单例模式 (Singleton Pattern)**：确保一个类只有一个实例，并提供一个全局访问点。
2. **工厂模式 (Factory Pattern)**：创建对象的过程封装在一个工厂类中，以便根据需求创建不同类型的对象。**工厂模式**通常用于创建单一类型的对象，它只有一个工厂类负责创建这一种对象。
3. **抽象工厂模式 (Abstract Factory Pattern)**：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定它们的具体类。用于创建一组相关的对象，这组对象通常有某种关联或依赖关系，每个工厂类负责创建其中一组对象。
4. **适配器模式 (Adapter Pattern)**：允许接口不兼容的类协同工作，将一个类的接口转换成客户端期望的接口。
5. **装饰器模式 (Decorator Pattern)**：动态地将责任附加到对象上，以扩展其功能。它是继承的替代方法。

### 3.Mybatis sql注入分析

**什么是sql注入？**

当我们使用字符串拼接的时候在，攻击者输入框中输入一些特殊字符，造成SQL语句执行异常。

**怎么防止sql注入？**

**使用参数化查询：**

- **定义方式**：在 MyBatis 中，你使用 `#{param}` 格式的占位符来表示参数。这些占位符将被 MyBatis 替换为实际参数值，并确保在替换过程中正确地进行转义和安全处理。

- **示例**：以下是使用参数化查询的示例，其中 `#{userId}` 是占位符，它将被实际的用户ID值替换。

  ```sql
  xmlCopy code<select id="getUserById" parameterType="int" resultType="User">
      SELECT * FROM users WHERE id = #{userId}
  </select>
  ```

**使用动态 SQL：** 

MyBatis 提供了动态 SQL 的功能，允许你根据不同的条件构建不同的 SQL 查询。当你需要根据用户输入动态构建查询时，确保正确地使用动态 SQL 并进行参数化处理。

例如，使用 `<if>` 元素来构建动态的 WHERE 子句：

```sql
xmlCopy code<select id="getUserByConditions" resultType="User">
    SELECT * FROM users
    <where>
        <if test="username != null">
            AND username = #{username}
        </if>
        <if test="email != null">
            AND email = #{email}
        </if>
    </where>
</select>
```



**SQL参数化查询为什么能够防止SQL注入？**

**1、参数化查询是什么**

参数化查询是指查询数据库时，在需要填入数据的地方，使用参数来给值。

**2、SQL 语句的执行处理**

SQL 语句按处理流程看有两类：即时 SQL、预处理 SQL。

- 即时 SQL

即时 SQL 从 DB 接收到最终执行完毕返回，大致的过程如下：

特点：一次编译，单次运行。

- 预处理 SQL

程序中某条 sql 可能会被反复调用，或者每次执行的时候只有个别的值不同。如果每次按即时 SQL 的流程来看，效率是比较低的。

这时候可以将 SQL 中的值用占位符代替，先生成 SQL 模板，然后再绑定参数，之后重复执行该语句的时候只需要替换参数，而不用再去进行词法和语义分析。可以视为 SQL 语句模板化或参数化。

**预处理 SQL 是如何防止 SQL 注入的**

待执行的 SQL 被编译后存放在缓存池中，DB 执行 execute 的时候，并不会再去编译一次，而是找到 SQL 模板，将参数传递给它然后执行。所以类似于 or 1==1 的命令会当成参数传递，而不会进行语义解析执行。

**#和$区别**

\#{} 解析为一个 JDBC 预编译语句（prepared statement）的参数标记符，一个 #{ } 被解析为一个参数占位符；而${}仅仅为一个纯碎的 string 替换，在动态 SQL 解析阶段将会进行变量替换。

\#{} 解析之后会将String类型的数据自动加上引号，其他数据类型不会；而${} 解析之后是什么就是什么，他不会当做字符串处理。

\#{} 很大程度上可以防止SQL注入（SQL注入是发生在编译的过程中，因为恶意注入了某些特殊字符，最后被编译成了恶意的执行操作）；而{} 主要用于SQL拼接的时候，有很大的SQL注入隐患。 

在某些特殊场合下只能用${}，不能用#{}。

例如：在使用排序时ORDER BY ${id}，如果使用#{id}，则会被解析成ORDER BY “id”,这显然是一种错误的写法。·

## 得物一面：

### 1.线程间通信的方式

### 2.Redis持久化方式

Redis支持两种主要的持久化机制：快照（Snapshot）和日志追加（Append-Only File）。

1. 快照（Snapshot）持久化：
   - 快照持久化是将Redis数据库的状态定期保存到磁盘文件中。这个过程通过将内存中的数据以快照的形式写入一个二进制文件（dump.rdb）来完成。
   - 管理快照的频率可以通过配置文件中的参数来控制。可以设置在多少秒内，或者在多少个修改操作后生成一个快照。
   - 快照持久化的优点是它非常高效，因为它只需要在指定的时间间隔内创建快照文件，不需要在每次写操作时都进行磁盘写入。
   - 缺点是如果Redis在两次快照之间崩溃，可能会丢失最后一次快照之后的数据。
2. 日志追加（Append-Only File）持久化：
   - 日志追加持久化是将每个写操作追加到一个日志文件（appendonly.aof）中，而不是定期保存整个数据库快照。
   - 这种持久化方式更安全，因为每个写操作都被记录下来，可以确保数据的完整性。
   - 日志追加持久化的缺点是相对于快照持久化来说，它可能会占用更多的磁盘空间，因为每个写操作都会被记录下来。
   - 此外，日志追加持久化在某些情况下可能会降低写入性能，因为每个写操作都需要追加到文件中。

## 云智一面：

1. 代码题，找参加的人数，求出频次最高的。不用map怎么统计频次？怎么原地统计？
2. 怎么让你写的Map查找时间复杂度最高？
3. newHashMap时候的参数有哪些？
4. 哪些变量存在堆中，哪些存在栈中？
5. 怎么让写的代码堆溢出？写一个看看
6. 怎么让写的代码栈溢出？
7. 了解迭代器吗？
8. Hash解决冲突的方式？
9. concurrentHashMap底层？
10. 红黑树和普通的平衡二叉树的区别？
11. 索引失效
12. 手写SQL
13. 索引数据结构

