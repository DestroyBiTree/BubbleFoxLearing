# 缓存基础

**缓存的本质是一个内存Hash表，数据缓存以一对key，Value的形式存储在内存Hash表中。**

缓存主要用来存放那些读写比较高，很少变化的数据，如商品的类目信息，热门词的搜索列表信息，热门商品信息等。应用程序在读取数据时，先到缓存中读取，如果读取不到或数据已经失效，再访问数据库，并将数据写入缓存。

# 一、本地缓存

**背景**：

在高性能的服务架构设计中，缓存是一个不可或缺的环节。在实际的项目中，我们通常会将一些热点数据存储到Redis或Memcached这类缓存中间件中，只有当缓存的访问没有命中时再查询数据库。在提升访问速度的同时，也能降低数据库的压力。

随着不断的发展，这一架构也产生了改进，在一些场景下可能单纯使用Redis类的远程缓存已经不够了，还需要进一步配合**本地缓存**使用，从而再次提升程序的**响应速度与服务性能**。于是，就产生了使用<font color='orange'>本地缓存作为一级缓存</font>，再加上<font color='orange'>远程缓存作为二级缓存的两级缓存</font>架构。

在先不考虑并发等复杂问题的情况下，两级缓存的访问流程可以用下面这张图来表示：

**本地缓存的概念：**本地缓存是指和应用程序在同一个进程内的内存空间去存储数据，数据的读写都是在同一个进程内完成的。

**本地缓存优点：**低依赖、轻量、简单、成本低。

本地缓存不需要远程网络请求去操作内存空间，没有额外的性能消耗，所以读取速度快。但是由于本地缓存占用了应用进程的内存空间，比如java进程的jvm内存空间，故不能进行大数据量存储。

**为什么要使用本地缓存**：

本地缓存基于本地环境的内存，访问速度非常快，对于一些变更频率低、实时性要求低的数据，可以放在本地缓存中，提升访问速度

使用本地缓存能够减少和Redis类的远程缓存间的数据交互，<font color='orange'>减少网络I/O开销</font>，降低这一过程中在网络通信上的耗时

**本地缓存缺点**：

（1）应用程序集群部署时，会存在数据更新问题（数据更新不一致）

本地缓存一般只能被同一个应用进程的程序访问，不能被其他应用程序进程访问。在单体应用集群部署时，如果数据库有数据需要更新，就要同步更新不同服务器节点上的本地缓存的数据来保证数据的一致性，但是这种操作的复杂度高，容易出错。可以基于redis的发布/订阅机制来实现各个部署节点的数据同步更新。

（2）数据会随着应用程序的重启而丢失（没有持久化机制）

因为本地缓存的数据是存储在应用进程的内存空间的，所以当应用进程重启时，本地缓存的数据会丢失。

（3）本地缓存容量受服务部署所在的机器限制明显。 如果当前系统服务所耗费的内存多，那么本地缓存可用的容量就很少。

**本地缓存的实现：**

（1）缓存存储的数据一般都是key-value键值对的数据结构，在java语言中，常用的字典实现包括<font color='orange'> HashMap</font> 和 <font color='orange'>ConcurretHashMap</font>。

ConcurrentHashMap 可以看作是线程安全版本的 HashMap ，两者都是存放 key/value 形式的键值对。但是，大部分场景来说不会使用这两者当做缓存，因为只提供了缓存的功能，并没有提供其他诸如过期时间之类的功能。一个稍微完善一点的缓存框架至少要提供：<font color='orange'>过期时间、淘汰机制、命中率统计</font>这三点。

（2）Ehcache 、 Guava Cache 、 Spring Cache 这三者是使用的比较多的本地缓存框架。

Ehcache 的话相比于其他两者更加重量。Ehcache 支持可以嵌入到 hibernate 和 mybatis 作为多级缓存，并且可以将缓存的数据持久化到本地磁盘中、同时也提供了集群方案（比较鸡肋，可忽略）。

Guava Cache 和 Spring Cache 两者的话比较像。 Guava 相比于 Spring Cache 的话使用的更多一点，它提供了 API 非常方便我们使用，同时也提供了设置缓存有效时间等功能。它的内部实现也比较干净，很多地方都和 ConcurrentHashMap 的思想有异曲同工之妙。

Caffeine是基于java8实现的新一代缓存工具，缓存性能接近理论最优。可以看作是<font color='orange'>Guava Cache的增强版</font>，功能上两者类似，不同的是Caffeine采用了一种结合LRU、LFU优点的算法：W-TinyLFU，在性能上有明显的优越性

使用 Spring Cache 的注解实现缓存的话，代码会看着很干净和优雅，但是很容易出现问题比如<font color='orange'>缓存穿透、内存溢出</font>。

**本地缓存问题及解决**：

缓存一致性

两级缓存与数据库的数据要保持一致，一旦数据发生了修改，在修改数据库的同时，本地缓存、远程缓存应该同步更新。

解决方案1: MQ

![image-20230404205431413](C:\Users\SalmonRun\AppData\Roaming\Typora\typora-user-images\image-20230404205431413.png)

一般现在部署都是集群部署，有多个不同节点的本地缓存; 可以使用MQ的广播模式，当数据修改时向MQ发送消息，节点监听并消费消息，删除本地缓存，达到最终一致性；

解决方案2：Canal + MQ

如果你不想在你的业务代码发送MQ消息，还可以适用近几年比较流行的方法：<font color='orange'>订阅数据库变更日志，再操作缓存</font>。Canal 订阅Mysql的 Binlog日志，当发生变化时向MQ发送消息，进而也实现数据一致性。

![image-20230404205502565](C:\Users\SalmonRun\AppData\Roaming\Typora\typora-user-images\image-20230404205502565.png)

# 二、分布式缓存

**什么是分布式缓存：**

指将缓存部署在多个服务器组成的集群中，以集群方式提供缓存服务，在分布式环境或系统下，把一些热门数据存储到离用户近，离应用近的位置，并尽量存储到更快的设备以减少远程数据传输的延迟。

![image-20230404211636362](C:\Users\SalmonRun\AppData\Roaming\Typora\typora-user-images\image-20230404211636362.png)

使用分布式缓存之后，缓存服务可以部署在一台单独的服务器上，即使同一个相同的服务部署在多台机器上，也是使用的同一份缓存。 并且，单独的分布式缓存服务的性能、容量和提供的功能都要更加强大。

**分布式缓存的方案有哪些？**

Redis和 Memcached。后者几乎被Redis取代。

**Redis相对于MemCash的优势有**：

1.支持快照和持久化

2.支持Master-Slave主从复制

3.支持更加丰富的数据类型

## （一）Redis

Redis是一个开源的使用ANSI C语言编写，支持网络。可基于内存亦可持久化的日志型key-value数据库，并提供多种语言的API。

其特点是：

1）内存数据库 完全基于内存，绝大部分请求是纯粹的内存操作，非常快。

2）单线程 意味着它不需要处理线程间的通信问题，不需要频繁切换上下文。

3）采用io多路复用模型

### **使用缓存所带来的问题：**

#### 1.缓存一致性问题

一般情况下缓存都只是为了我们提升数据检索性能的一个媒介，它不会作为最后的数据存储归宿，通常我们会把最终的数据保存到数据库中去。这样的情况下我们的数据就会分别存在于缓存和数据库中，当我们操作两个数据库和缓存的时候就会存在修改了数据库但是没更新缓存数据、又或者更新了缓存数据库的数据又没同步修改，像这种数据库的数据和缓存数据不同步的问题就属于缓存数据一致性问题。

缓存一致性问题主要原因是在于修改数据库的同时还需要把最新的数据更新到缓存中去，但是这个过程可能出现一些问题从而导致缓存数据与数据库的数据不一致

#### **解决方案（**常见的缓存更新策略有哪几种**）：**

##### 1.Cache Aside Pattern（旁路缓存模式）

Cache Aside Pattern 是我们平时使用比较多的一个缓存读写模式，比较适合读请求比较多的场景。

Cache Aside Pattern 中服务端需要同时维系数据库（后文简称 db）和缓存（后文简称 cache），并且是以 db 的结果为准。

**写：**

（1）先更新DB

（2）直接删除cache

- 为什么直接删？

  1. **对服务端资源造成浪费 ：**删除 cache 更加直接，这是因为 cache 中存放的一些数据需要服务端经过大量的计算才能得出，会消耗服务端的资源，是一笔不晓得开销。如果频繁修改 db，就能会导致需要频繁更新 cache，而 cache 中的数据可能都没有被访问到。

  2. **产生数据不一致问题 ：**并发场景下，更新 cache 产生数据不一致性问题的概率会更大。

- 为什么不能先删后写？

  有可能出现db和cache不一致的问题。假如以下场景：

  A删除cache

  B读到DB

  A更新DB

  DB和cache不一致的问题。

- 那先更新再删除为什么就不会？

  会，但是概率很小。因为缓存的写入速度是比数据库的写入速度快很多。

  请求 1 从 db 读数据 A；

  请求 2 更新 db 中的数据 A（此时缓存中无数据 A ，故不用执行删除缓存操作 ）；

  请求 1 将数据 A 写入 cache。

  cache中存放的是旧值。

**读** **:**

（1）从 cache 中读取数据，读取到就直接返回；

（2）cache 中读取不到的话，就从 db 中读取数据返回；

（3） 再把 db 中读取到的数据放到 cache 中。

**旁路缓存模式有什么缺陷？**

**缺陷** **1：首次请求数据一定不在** **cache** **的问题**。

解决办法：提前把热点数据放进缓存。

**缺陷** **2**：**写操作比较频繁的话导致** **cache** **中的数据会被频繁被删除，这样会影响缓存命中率 。**

解决办法：

1. 数据库和缓存数据强一致场景 ：更新 db 的时候同样更新 cache，不过我们需要加一个锁/分布式锁来保证更新 cache 的时候不存在线程安全问题。

2. 可以短暂地允许数据库和缓存数据不一致的场景 ：更新 db 的时候同样更新 cache，但是给缓存加。

   一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小。

#### 2.缓存击穿问题（缓存雪崩）

**大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机**时，如果此时有大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃，这就是**缓存雪崩**的问题。

**<font color='orange'>当大量缓存数据同一时间失效</font>：**

1. 均匀设置过期时间

如果要给缓存数据设置过期时间，应该避免将大量的数据设置成同一个过期时间。我们可以在对缓存数据设置过期时间时，**给这些数据的过期时间加上一个随机数**，这样就保证数据不会在同一时间过期。

2. 互斥锁

当业务线程在处理用户请求时，**如果发现访问的数据不在 Redis 里，就加个互斥锁，保证同一时间内只有一个请求来构建缓存**（从数据库读取数据，再将数据更新到 Redis 里），当缓存构建完成后，再释放锁。未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。

实现互斥锁的时候，最好设置**超时时间**，不然第一个请求拿到了锁，然后这个请求发生了某种意外而一直阻塞，一直不释放锁，这时其他请求也一直拿不到锁，整个系统就会出现无响应的现象。

3. 双 key 策略

我们对缓存数据可以使用两个 key，一个是**主 key，会设置过期时间**，一个是**备 key，不会设置过期**，它们只是 key 不一样，但是 value 值是一样的，相当于给缓存数据做了个副本。

当业务线程访问不到「主 key 」的缓存数据时，就直接返回「备 key 」的缓存数据，然后在更新缓存的时候，**同时更新「主 key 」和「备 key 」的数据。**

4. 后台更新缓存

业务线程不再负责更新缓存，缓存也不设置有效期，而是**让缓存“永久有效”，并将更新缓存的工作交由后台线程定时更新**。

**<font color='orange'>当Redis宕机</font>：**

1. 服务熔断或请求限流机制

因为 Redis 故障宕机而导致缓存雪崩问题时，我们可以启动**服务熔断**机制，**暂停业务应用对缓存服务的访问，直接返回错误**，不用再继续访问数据库，从而降低对数据库的访问压力，保证数据库系统的正常运行，然后等到 Redis 恢复正常后，再允许业务应用访问缓存服务。

服务熔断机制是保护数据库的正常允许，但是暂停了业务应用访问缓存服系统，全部业务都无法正常工作

为了减少对业务的影响，我们可以启用**请求限流**机制，**只将少部分请求发送到数据库进行处理，再多的请求就在入口直接拒绝服务**，等到 Redis 恢复正常并把缓存预热完后，再解除请求限流的机制。

2. 构建 Redis 缓存高可靠集群

服务熔断或请求限流机制是缓存雪崩发生后的应对方案，我们最好通过**主从节点的方式构建 Redis 缓存高可靠集群**。

如果 Redis 缓存的主节点故障宕机，从节点可以切换成为主节点，继续提供缓存服务，避免了由于 Redis 故障宕机而导致的缓存雪崩问题。

#### 3.缓存穿透问题

当用户访问的数据，**既不在缓存中，也不在数据库中**，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求。那么当有大量这样的请求到来时，数据库的压力骤增，这就是**缓存穿透**的问题。

1.非法请求的限制

当有大量恶意请求访问不存在的数据的时候，也会发生缓存穿透，因此在 API 入口处我们要判断求请求参数是否合理，请求参数是否含有非法值、请求字段是否存在，如果判断出是恶意请求就直接返回错误，避免进一步访问缓存和数据库。

2.缓存空值或者默认值

当我们线上业务发现缓存穿透的现象时，可以针对查询的数据，在缓存中设置一个空值或者默认值，这样后续请求就可以从缓存中读取到空值或者默认值，返回给应用，而不会继续查询数据库。

3.使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在。

我们可以在写入数据库数据时，使用布隆过滤器做个标记，然后在用户请求到来时，业务线程确认缓存失效后，可以通过查询布隆过滤器快速判断数据是否存在，如果不存在，就不用通过查询数据库来判断数据是否存在。

即使发生了缓存穿透，大量请求只会查询 Redis 和布隆过滤器，而不会查询数据库，保证了数据库能正常运行，Redis 自身也是支持布隆过滤器的。 

在数据库写入数据 x 后，把数据 x 标记在布隆过滤器时，数据 x 会被 3 个哈希函数分别计算出 3 个哈希值，然后在对这 3 个哈希值对 8 取模，假设取模的结果为 1、4、6，然后把位图数组的第 1、4、6 位置的值设置为 1。**当应用要查询数据 x 是否数据库时，通过布隆过滤器只要查到位图数组的第 1、4、6 位置的值是否全为 1，只要有一个为 0，就认为数据 x 不在数据库中**。

布隆过滤器由于是基于哈希函数实现查找的，高效查找的同时**存在哈希冲突的可能性**，比如数据 x 和数据 y 可能都落在第 1、4、6 位置，而事实上，可能数据库中并不存在数据 y，存在误判的情况。

所以，**查询布隆过滤器说数据存在，并不一定证明数据库中存在这个数据，但是查询到数据不存在，数据库中一定就不存在这个数据**。

![img](https://img-blog.csdnimg.cn/img_convert/061e2c04e0ebca3425dd75dd035b6b7b.png)

