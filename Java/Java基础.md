# Java基础
## 面向对象：
继承是类与类之间的关系，不是对象与对象之间的关系。
多态：同一个行为具有多个不同表现形式或形态的能力。
多态的必要条件：
继承，重写，父类的引用指向子类的对象。
## 数据类型：

Java中有8中基本数据类型：

整型4种：byte，int，short，long

浮点型2种：float，double

非数值类型：char，boolean

### 什么是包装类型？

包装类型（Wrapper Types）是一种将基本数据类型（如 `int`、`char`、`boolean` 等）封装为对象的机制。在 Java 中，所有数据类型都分为两类：基本数据类型和引用数据类型。基本数据类型是不具备面向对象特性的，无法作为对象直接参与面向对象编程。为了解决这个问题，Java 提供了对应的包装类型，允许将基本数据类型转换为对象，从而可以在面向对象的上下文中使用。

以下是一些常见的基本数据类型及其对应的包装类型：

- `byte` -> `Byte`
- `short` -> `Short`
- `int` -> `Integer`
- `long` -> `Long`
- `float` -> `Float`
- `double`-> `Double`
- `char` -> `Character`
- `boolean` -> `Boolean`
扩展的数字类：BigInteger、BigDecimal

包装类型都属于 Java 的标准类库，位于 `java.lang` 包中，因此它们不需要显式导入就可以使用。

包装类型的主要作用包括：

1. **允许使用泛型：** 泛型类和方法不能使用基本数据类型作为类型参数，但可以使用对应的包装类型。

2. **提供额外功能：** 包装类型提供了许多有用的方法，用于对数据进行操作和转换，比如转换为字符串、数值比较等。

3. **支持 `null` 值：** 包装类型可以持有 `null` 值，而基本数据类型不行。这对于表示缺失或未初始化的数据是很有用的。

4. **参与集合操作：** 包装类型可以放入集合（如 `List`、`Set`）等容器中，而基本数据类型不能直接放入集合。

5. **自动装箱与拆箱：** Java 提供了自动装箱（Autoboxing）和自动拆箱（Unboxing）的机制，使得基本数据类型和包装类型之间的转换更加方便。自动装箱是指将基本数据类型自动转换为对应的包装类型，自动拆箱是指将包装类型自动转换为基本数据类型。

   

## 抽象类和接口：

**共同点：**

1. **抽象性：** 抽象类和接口都是抽象的，不能被实例化，只能被子类实现或继承。
2. **约束子类：** 它们都用于定义规范，约束子类实现特定的方法或功能。
3. **类之间关系：** 都可以用于实现类之间的继承关系，帮助构建类的层次结构。

**区别：**

1. **继承：**
   - **抽象类：** 子类可以继承一个抽象类，并且只能继承一个类，Java中只支持单继承。
   - **接口：** 子类可以实现多个接口，允许多继承。类可以同时实现多个接口。
2. **构造方法：**
   - **抽象类：** 可以有构造方法，可以用来初始化抽象类的成员。
   - **接口：** 不能有构造方法，因为接口是纯粹的规范，没有实际的实例化过程。
3. **字段和变量：**
   - **抽象类：** 可以有实例字段（非静态字段），也可以有静态字段。
   - **接口：** 只能有常量（`public static final`）字段，不允许实例字段和静态字段。
4. **方法实现：**
   - **抽象类：** 可以包含具体方法（非抽象方法），子类可以选择性地重写或调用这些方法。但是抽象方法必须被实现。
   - **接口：** 所有方法都是抽象的，子类必须实现接口中的所有方法。
5. **访问修饰符：**
   - **抽象类：** 可以有不同的访问修饰符，包括 `public`、`protected`、`default` 和 `private`。
   - **接口：** 所有成员默认为 `public`，不能使用其他访问修饰符。
6. **设计目的：**
   - **抽象类：** 用于共享代码和行为，可以包含一些通用实现。
   - **接口：** 用于定义一组契约，强制实现类遵循特定的方法签名，实现多态性。

通常来说，如果你希望定义一个共享代码和行为的基类，你可能会选择使用抽象类。而如果你希望定义一组方法的规范，以便让不同的类来实现，你可能会选择使用接口。在设计时，需要根据具体情况来选择使用抽象类还是接口。

## 浅拷贝深拷贝：

**浅拷贝（Shallow Copy）：** 浅拷贝创建一个新对象，然后将原始对象的字段值复制到新对象中。但是，如果原始对象的字段值是引用类型（如数组、集合、对象等），则浅拷贝只会复制这些引用，而不会复制引用指向的对象。结果是，新对象和原始对象将共享相同的引用对象。

**深拷贝（Deep Copy）：** 深拷贝创建一个新对象，并递归地复制原始对象的所有字段值，包括引用类型的字段所引用的对象。这样，新对象和原始对象将完全独立，不共享任何引用对象。

## hashcode和equals：

**`equals()` 方法：** `equals()` 方法用于判断两个对象是否在逻辑上相等。在默认情况下，`equals()` 方法是比较对象的引用是否相等，即对象在内存中的地址是否一致。但是，对于自定义类，我们通常需要根据对象的内容来定义相等性，因此需要重写这个方法。

**`hashCode()` 方法：** `hashCode()` 方法返回对象的哈希码，一个整数值。哈希码用于在哈希表等数据结构中快速查找对象。在默认情况下，`hashCode()` 方法返回的是对象的内存地址的哈希值。但是，如果我们重写了 `equals()` 方法，那么通常也需要重写 `hashCode()` 方法，以保证在集合中的对象存储和检索能够正确工作。

为什么要有这两个方法？

1. **确保逻辑相等性：** `equals()` 方法允许我们定义两个对象在业务逻辑上是否相等。例如，如果我们定义了 `Person` 类，希望两个人具有相同的姓名和年龄，即使它们在内存中的引用不同，我们仍然可以通过重写 `equals()` 方法来判断它们是否相等。
2. **正确性和一致性：** 如果两个对象在逻辑上相等（根据 `equals()` 方法的定义），那么它们的哈希码应该相等。如果在自定义类中重写了 `equals()` 方法，但没有重写 `hashCode()` 方法，那么在使用集合类时可能会导致不一致的结果。
3. **哈希表性能：** 在哈希表中存储大量数据时，需要能够快速查找和访问对象。`hashCode()` 方法返回的哈希码可以用于分布在哈希表中，从而快速定位对象。
